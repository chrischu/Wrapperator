//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Wrapperator.Wrappers.IO.Compression
{
  
  
  /// <summary>Provides methods and properties for compressing and decompressing streams by using the Deflate algorithm.</summary>
  public class DeflateStreamWrapper : StreamWrapper, Wrapperator.Interfaces.IO.Compression.IDeflateStream
  {
    
    internal System.IO.Compression.DeflateStream DeflateStream { get; private set; }

    
    internal DeflateStreamWrapper(System.IO.Compression.DeflateStream deflateStream) : 
        base(deflateStream)
    {
      DeflateStream = deflateStream;
    }
    
    public Wrapperator.Interfaces.IO.IStream BaseStream
    {
      get
      {
        return new Wrapperator.Wrappers.IO.StreamWrapper(DeflateStream.BaseStream);
      }
    }
    
    public new bool CanRead
    {
      get
      {
        return DeflateStream.CanRead;
      }
    }
    
    public new bool CanWrite
    {
      get
      {
        return DeflateStream.CanWrite;
      }
    }
    
    public new bool CanSeek
    {
      get
      {
        return DeflateStream.CanSeek;
      }
    }
    
    public new long Length
    {
      get
      {
        return DeflateStream.Length;
      }
    }
    
    public new long Position
    {
      get
      {
        return DeflateStream.Position;
      }
      set
      {
        DeflateStream.Position = value;
      }
    }
    
    public new bool CanTimeout
    {
      get
      {
        return DeflateStream.CanTimeout;
      }
    }
    
    public new int ReadTimeout
    {
      get
      {
        return DeflateStream.ReadTimeout;
      }
      set
      {
        DeflateStream.ReadTimeout = value;
      }
    }
    
    public new int WriteTimeout
    {
      get
      {
        return DeflateStream.WriteTimeout;
      }
      set
      {
        DeflateStream.WriteTimeout = value;
      }
    }
    
    /// <summary>The current implementation of this method has no functionality.</summary>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed.</exception>
    public new void Flush()
    {
      DeflateStream.Flush();
    }
    
    /// <summary>This operation is not supported and always throws a <see cref="T:System.NotSupportedException" />.</summary>
    /// <returns>A long value.</returns>
    /// <param name="offset">The location in the stream.</param>
    /// <param name="origin">One of the <see cref="T:System.IO.SeekOrigin" /> values.</param>
    /// <exception cref="T:System.NotSupportedException">This property is not supported on this stream.</exception>
    public new long Seek(long offset, System.IO.SeekOrigin origin)
    {
      return DeflateStream.Seek(offset, origin);
    }
    
    /// <summary>This operation is not supported and always throws a <see cref="T:System.NotSupportedException" />.</summary>
    /// <param name="value">The length of the stream.</param>
    /// <exception cref="T:System.NotSupportedException">This property is not supported on this stream.</exception>
    public new void SetLength(long value)
    {
      DeflateStream.SetLength(value);
    }
    
    /// <summary>Reads a number of decompressed bytes into the specified byte array.</summary>
    /// <returns>The number of bytes that were read into the byte array.</returns>
    /// <param name="array">The array to store decompressed bytes.</param>
    /// <param name="offset">The byte offset in <paramref name="array" /> at which the read bytes will be placed.</param>
    /// <param name="count">The maximum number of decompressed bytes to read.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="array" /> is null.</exception>
    /// <exception cref="T:System.InvalidOperationException">The <see cref="T:System.IO.Compression.CompressionMode" /> value was Compress when the object was created.- or - The underlying stream does not support reading.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="offset" /> or <paramref name="count" /> is less than zero.-or-<paramref name="array" /> length minus the index starting point is less than <paramref name="count" />.</exception>
    /// <exception cref="T:System.IO.InvalidDataException">The data is in an invalid format.</exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed.</exception>
    public new int Read(byte[] array, int offset, int count)
    {
      return DeflateStream.Read(array, offset, count);
    }
    
    /// <summary>Begins an asynchronous read operation. (Consider using the <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> method instead; see the Remarks section.)</summary>
    /// <returns>An  object that represents the asynchronous read operation, which could still be pending.</returns>
    /// <param name="array">The byte array to read the data into.</param>
    /// <param name="offset">The byte offset in <paramref name="array" /> at which to begin reading data from the stream.</param>
    /// <param name="count">The maximum number of bytes to read.</param>
    /// <param name="asyncCallback">An optional asynchronous callback, to be called when the read operation is complete.</param>
    /// <param name="asyncState">A user-provided object that distinguishes this particular asynchronous read request from other requests.</param>
    /// <exception cref="T:System.IO.IOException">The method tried to read asynchronously past the end of the stream, or a disk error occurred.</exception>
    /// <exception cref="T:System.ArgumentException">One or more of the arguments is invalid.</exception>
    /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
    /// <exception cref="T:System.NotSupportedException">The current <see cref="T:System.IO.Compression.DeflateStream" /> implementation does not support the read operation.</exception>
    /// <exception cref="T:System.InvalidOperationException">This call cannot be completed. </exception>
    public new System.IAsyncResult BeginRead(byte[] array, int offset, int count, System.AsyncCallback asyncCallback, object asyncState)
    {
      return DeflateStream.BeginRead(array, offset, count, asyncCallback, asyncState);
    }
    
    /// <summary>Waits for the pending asynchronous read to complete. (Consider using the <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> method instead; see the Remarks section.)</summary>
    /// <returns>The number of bytes read from the stream, between 0 (zero) and the number of bytes you requested. <see cref="T:System.IO.Compression.DeflateStream" /> returns 0 only at the end of the stream; otherwise, it blocks until at least one byte is available.</returns>
    /// <param name="asyncResult">The reference to the pending asynchronous request to finish.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="asyncResult" /> is null.</exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Compression.DeflateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</exception>
    /// <exception cref="T:System.SystemException">An exception was thrown during a call to <see cref="M:System.Threading.WaitHandle.WaitOne" />.</exception>
    /// <exception cref="T:System.InvalidOperationException">The end call is invalid because asynchronous read operations for this stream are not yet complete.</exception>
    /// <exception cref="T:System.InvalidOperationException">The stream is null.</exception>
    public new int EndRead(System.IAsyncResult asyncResult)
    {
      return DeflateStream.EndRead(asyncResult);
    }
    
    /// <summary>Writes compressed bytes to the underlying stream from the specified byte array.</summary>
    /// <param name="array">The buffer that contains the data to compress.</param>
    /// <param name="offset">The byte offset in <paramref name="array" /> from which the bytes will be read.</param>
    /// <param name="count">The maximum number of bytes to write.</param>
    public new void Write(byte[] array, int offset, int count)
    {
      DeflateStream.Write(array, offset, count);
    }
    
    /// <summary>Begins an asynchronous write operation. (Consider using the <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> method instead; see the Remarks section.)</summary>
    /// <returns>An  object that represents the asynchronous write operation, which could still be pending.</returns>
    /// <param name="array">The buffer to write data from.</param>
    /// <param name="offset">The byte offset in <paramref name="buffer" /> to begin writing from.</param>
    /// <param name="count">The maximum number of bytes to write.</param>
    /// <param name="asyncCallback">An optional asynchronous callback, to be called when the write operation is complete.</param>
    /// <param name="asyncState">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
    /// <exception cref="T:System.IO.IOException">The method tried to write asynchronously past the end of the stream, or a disk error occurred.</exception>
    /// <exception cref="T:System.ArgumentException">One or more of the arguments is invalid.</exception>
    /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed.</exception>
    /// <exception cref="T:System.NotSupportedException">The current <see cref="T:System.IO.Compression.DeflateStream" /> implementation does not support the write operation.</exception>
    /// <exception cref="T:System.InvalidOperationException">The write operation cannot be performed because the stream is closed.</exception>
    public new System.IAsyncResult BeginWrite(byte[] array, int offset, int count, System.AsyncCallback asyncCallback, object asyncState)
    {
      return DeflateStream.BeginWrite(array, offset, count, asyncCallback, asyncState);
    }
    
    /// <summary>Ends an asynchronous write operation. (Consider using the <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> method instead; see the Remarks section.)</summary>
    /// <param name="asyncResult">A reference to the outstanding asynchronous I/O request.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="asyncResult" /> is null.</exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Compression.DeflateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream.</exception>
    /// <exception cref="T:System.Exception">An exception was thrown during a call to <see cref="M:System.Threading.WaitHandle.WaitOne" />.</exception>
    /// <exception cref="T:System.InvalidOperationException">The stream is null.</exception>
    /// <exception cref="T:System.InvalidOperationException">The end write call is invalid.</exception>
    public new void EndWrite(System.IAsyncResult asyncResult)
    {
      DeflateStream.EndWrite(asyncResult);
    }
    
    /// <summary>Asynchronously reads the bytes from the current stream and writes them to another stream.</summary>
    /// <returns>A task that represents the asynchronous copy operation.</returns>
    /// <param name="destination">The stream to which the contents of the current stream will be copied.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="destination" /> is null.</exception>
    /// <exception cref="T:System.ObjectDisposedException">Either the current stream or the destination stream is disposed.</exception>
    /// <exception cref="T:System.NotSupportedException">The current stream does not support reading, or the destination stream does not support writing.</exception>
    public new System.Threading.Tasks.Task CopyToAsync(Wrapperator.Interfaces.IO.IStream destination)
    {
      return DeflateStream.CopyToAsync(destination == null ? default(System.IO.Stream) : ((Wrapperator.Wrappers.IO.StreamWrapper)destination).Stream);
    }
    
    /// <summary>Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified buffer size.</summary>
    /// <returns>A task that represents the asynchronous copy operation.</returns>
    /// <param name="destination">The stream to which the contents of the current stream will be copied.</param>
    /// <param name="bufferSize">The size, in bytes, of the buffer. This value must be greater than zero. The default size is 81920.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="destination" /> is null.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="buffersize" /> is negative or zero.</exception>
    /// <exception cref="T:System.ObjectDisposedException">Either the current stream or the destination stream is disposed.</exception>
    /// <exception cref="T:System.NotSupportedException">The current stream does not support reading, or the destination stream does not support writing.</exception>
    public new System.Threading.Tasks.Task CopyToAsync(Wrapperator.Interfaces.IO.IStream destination, int bufferSize)
    {
      return DeflateStream.CopyToAsync(destination == null ? default(System.IO.Stream) : ((Wrapperator.Wrappers.IO.StreamWrapper)destination).Stream, bufferSize);
    }
    
    /// <summary>Asynchronously reads the bytes from the current stream and writes them to another stream, using a specified buffer size and cancellation token.</summary>
    /// <returns>A task that represents the asynchronous copy operation.</returns>
    /// <param name="destination">The stream to which the contents of the current stream will be copied.</param>
    /// <param name="bufferSize">The size, in bytes, of the buffer. This value must be greater than zero. The default size is 81920.</param>
    /// <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="destination" /> is null.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="buffersize" /> is negative or zero.</exception>
    /// <exception cref="T:System.ObjectDisposedException">Either the current stream or the destination stream is disposed.</exception>
    /// <exception cref="T:System.NotSupportedException">The current stream does not support reading, or the destination stream does not support writing.</exception>
    public new System.Threading.Tasks.Task CopyToAsync(Wrapperator.Interfaces.IO.IStream destination, int bufferSize, System.Threading.CancellationToken cancellationToken)
    {
      return DeflateStream.CopyToAsync(destination == null ? default(System.IO.Stream) : ((Wrapperator.Wrappers.IO.StreamWrapper)destination).Stream, bufferSize, cancellationToken);
    }
    
    /// <summary>Reads the bytes from the current stream and writes them to another stream.</summary>
    /// <param name="destination">The stream to which the contents of the current stream will be copied.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="destination" /> is null.</exception>
    /// <exception cref="T:System.NotSupportedException">The current stream does not support reading.-or-<paramref name="destination" /> does not support writing.</exception>
    /// <exception cref="T:System.ObjectDisposedException">Either the current stream or <paramref name="destination" /> were closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
    public new void CopyTo(Wrapperator.Interfaces.IO.IStream destination)
    {
      DeflateStream.CopyTo(destination == null ? default(System.IO.Stream) : ((Wrapperator.Wrappers.IO.StreamWrapper)destination).Stream);
    }
    
    /// <summary>Reads the bytes from the current stream and writes them to another stream, using a specified buffer size.</summary>
    /// <param name="destination">The stream to which the contents of the current stream will be copied.</param>
    /// <param name="bufferSize">The size of the buffer. This value must be greater than zero. The default size is 81920.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="destination" /> is null.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="bufferSize" /> is negative or zero.</exception>
    /// <exception cref="T:System.NotSupportedException">The current stream does not support reading.-or-<paramref name="destination" /> does not support writing.</exception>
    /// <exception cref="T:System.ObjectDisposedException">Either the current stream or <paramref name="destination" /> were closed before the <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> method was called.</exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
    public new void CopyTo(Wrapperator.Interfaces.IO.IStream destination, int bufferSize)
    {
      DeflateStream.CopyTo(destination == null ? default(System.IO.Stream) : ((Wrapperator.Wrappers.IO.StreamWrapper)destination).Stream, bufferSize);
    }
    
    /// <summary>Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream. Instead of calling this method, ensure that the stream is properly disposed.</summary>
    /// <filterpriority>1</filterpriority>
    public new void Close()
    {
      DeflateStream.Close();
    }
    
    /// <summary>Asynchronously clears all buffers for this stream and causes any buffered data to be written to the underlying device.</summary>
    /// <returns>A task that represents the asynchronous flush operation.</returns>
    /// <exception cref="T:System.ObjectDisposedException">The stream has been disposed.</exception>
    public new System.Threading.Tasks.Task FlushAsync()
    {
      return DeflateStream.FlushAsync();
    }
    
    /// <summary>Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests.</summary>
    /// <returns>A task that represents the asynchronous flush operation.</returns>
    /// <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</param>
    /// <exception cref="T:System.ObjectDisposedException">The stream has been disposed.</exception>
    public new System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken)
    {
      return DeflateStream.FlushAsync(cancellationToken);
    }
    
    /// <summary>Asynchronously reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.</summary>
    /// <returns>A task that represents the asynchronous read operation. The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer. The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached. </returns>
    /// <param name="buffer">The buffer to write the data into.</param>
    /// <param name="offset">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</param>
    /// <param name="count">The maximum number of bytes to read.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="buffer" /> is null.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="offset" /> or <paramref name="count" /> is negative.</exception>
    /// <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</exception>
    /// <exception cref="T:System.NotSupportedException">The stream does not support reading.</exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream has been disposed.</exception>
    /// <exception cref="T:System.InvalidOperationException">The stream is currently in use by a previous read operation. </exception>
    public new System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count)
    {
      return DeflateStream.ReadAsync(buffer, offset, count);
    }
    
    /// <summary>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</summary>
    /// <returns>A task that represents the asynchronous read operation. The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer. The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached. </returns>
    /// <param name="buffer">The buffer to write the data into.</param>
    /// <param name="offset">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</param>
    /// <param name="count">The maximum number of bytes to read.</param>
    /// <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="buffer" /> is null.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="offset" /> or <paramref name="count" /> is negative.</exception>
    /// <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</exception>
    /// <exception cref="T:System.NotSupportedException">The stream does not support reading.</exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream has been disposed.</exception>
    /// <exception cref="T:System.InvalidOperationException">The stream is currently in use by a previous read operation. </exception>
    public new System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken)
    {
      return DeflateStream.ReadAsync(buffer, offset, count, cancellationToken);
    }
    
    /// <summary>Asynchronously writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.</summary>
    /// <returns>A task that represents the asynchronous write operation.</returns>
    /// <param name="buffer">The buffer to write data from.</param>
    /// <param name="offset">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</param>
    /// <param name="count">The maximum number of bytes to write.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="buffer" /> is null.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="offset" /> or <paramref name="count" /> is negative.</exception>
    /// <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</exception>
    /// <exception cref="T:System.NotSupportedException">The stream does not support writing.</exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream has been disposed.</exception>
    /// <exception cref="T:System.InvalidOperationException">The stream is currently in use by a previous write operation. </exception>
    public new System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count)
    {
      return DeflateStream.WriteAsync(buffer, offset, count);
    }
    
    /// <summary>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.</summary>
    /// <returns>A task that represents the asynchronous write operation.</returns>
    /// <param name="buffer">The buffer to write data from.</param>
    /// <param name="offset">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</param>
    /// <param name="count">The maximum number of bytes to write.</param>
    /// <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="buffer" /> is null.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="offset" /> or <paramref name="count" /> is negative.</exception>
    /// <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</exception>
    /// <exception cref="T:System.NotSupportedException">The stream does not support writing.</exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream has been disposed.</exception>
    /// <exception cref="T:System.InvalidOperationException">The stream is currently in use by a previous write operation. </exception>
    public new System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken)
    {
      return DeflateStream.WriteAsync(buffer, offset, count, cancellationToken);
    }
    
    /// <summary>Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.</summary>
    /// <returns>The unsigned byte cast to an Int32, or -1 if at the end of the stream.</returns>
    /// <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
    /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
    /// <filterpriority>2</filterpriority>
    public new int ReadByte()
    {
      return DeflateStream.ReadByte();
    }
    
    /// <summary>Writes a byte to the current position in the stream and advances the position within the stream by one byte.</summary>
    /// <param name="value">The byte to write to the stream. </param>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <exception cref="T:System.NotSupportedException">The stream does not support writing, or the stream is already closed. </exception>
    /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
    /// <filterpriority>2</filterpriority>
    public new void WriteByte(byte value)
    {
      DeflateStream.WriteByte(value);
    }
    
    protected override void Dispose(bool disposing)
    {
      base.Dispose(disposing);
      if (disposing)
      {
        DeflateStream.Dispose();
      }
    }
  }
}
