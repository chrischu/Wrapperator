//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Wrapperator.Wrappers.IO
{
  
  
  /// <summary>Reads primitive data types as binary values in a specific encoding.</summary>
  /// <filterpriority>2</filterpriority>
  public partial class BinaryReaderWrapper : Wrapperator.Interfaces.IO.IBinaryReader
  {
    
    private System.IO.BinaryReader _binaryReader;
    
    public static implicit operator System.IO.BinaryReader (BinaryReaderWrapper wrapper)
    {
      if (wrapper == null) return default(System.IO.BinaryReader);
      return wrapper._binaryReader;
    }
    
    public BinaryReaderWrapper(System.IO.BinaryReader binaryReader)
    {
      _binaryReader = binaryReader;
    }
    
    public System.IO.Stream BaseStream
    {
      get
      {
        return _binaryReader.BaseStream;
      }
    }
    
    /// <summary>Closes the current reader and the underlying stream.</summary>
    /// <filterpriority>2</filterpriority>
    public void Close()
    {
      _binaryReader.Close();
    }
    
    /// <summary>Returns the next available character and does not advance the byte or character position.</summary>
    /// <returns>The next available character, or -1 if no more characters are available or the stream does not support seeking.</returns>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <exception cref="T:System.ArgumentException">The current character cannot be decoded into the internal character buffer by using the <see cref="T:System.Text.Encoding" /> selected for the stream.</exception>
    /// <filterpriority>2</filterpriority>
    public int PeekChar()
    {
      return _binaryReader.PeekChar();
    }
    
    /// <summary>Reads characters from the underlying stream and advances the current position of the stream in accordance with the Encoding used and the specific character being read from the stream.</summary>
    /// <returns>The next character from the input stream, or -1 if no characters are currently available.</returns>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <filterpriority>2</filterpriority>
    public int Read()
    {
      return _binaryReader.Read();
    }
    
    /// <summary>Reads the specified number of characters from the stream, starting from a specified point in the character array.</summary>
    /// <returns>The total number of characters read into the buffer. This might be less than the number of characters requested if that many characters are not currently available, or it might be zero if the end of the stream is reached.</returns>
    /// <param name="buffer">The buffer to read data into. </param>
    /// <param name="index">The starting point in the buffer at which to begin reading into the buffer. </param>
    /// <param name="count">The number of characters to read. </param>
    /// <exception cref="T:System.ArgumentException">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />. -or-The number of decoded characters to read is greater than <paramref name="count" />. This can happen if a Unicode decoder returns fallback characters or a surrogate pair.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="buffer" /> is null. </exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="index" /> or <paramref name="count" /> is negative. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public int Read(char[] buffer, int index, int count)
    {
      return _binaryReader.Read(buffer, index, count);
    }
    
    /// <summary>Reads the specified number of bytes from the stream, starting from a specified point in the byte array. </summary>
    /// <returns>The number of bytes read into <paramref name="buffer" />. This might be less than the number of bytes requested if that many bytes are not available, or it might be zero if the end of the stream is reached.</returns>
    /// <param name="buffer">The buffer to read data into. </param>
    /// <param name="index">The starting point in the buffer at which to begin reading into the buffer. </param>
    /// <param name="count">The number of bytes to read. </param>
    /// <exception cref="T:System.ArgumentException">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />. -or-The number of decoded characters to read is greater than <paramref name="count" />. This can happen if a Unicode decoder returns fallback characters or a surrogate pair.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="buffer" /> is null. </exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="index" /> or <paramref name="count" /> is negative. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public int Read(byte[] buffer, int index, int count)
    {
      return _binaryReader.Read(buffer, index, count);
    }
    
    /// <summary>Reads a Boolean value from the current stream and advances the current position of the stream by one byte.</summary>
    /// <returns>true if the byte is nonzero; otherwise, false.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public bool ReadBoolean()
    {
      return _binaryReader.ReadBoolean();
    }
    
    /// <summary>Reads the next byte from the current stream and advances the current position of the stream by one byte.</summary>
    /// <returns>The next byte read from the current stream.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public byte ReadByte()
    {
      return _binaryReader.ReadByte();
    }
    
    /// <summary>Reads the specified number of bytes from the current stream into a byte array and advances the current position by that number of bytes.</summary>
    /// <returns>A byte array containing data read from the underlying stream. This might be less than the number of bytes requested if the end of the stream is reached.</returns>
    /// <param name="count">The number of bytes to read. This value must be 0 or a non-negative number or an exception will occur.</param>
    /// <exception cref="T:System.ArgumentException">The number of decoded characters to read is greater than <paramref name="count" />. This can happen if a Unicode decoder returns fallback characters or a surrogate pair.</exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="count" /> is negative. </exception>
    /// <filterpriority>2</filterpriority>
    public byte[] ReadBytes(int count)
    {
      return _binaryReader.ReadBytes(count);
    }
    
    /// <summary>Reads the next character from the current stream and advances the current position of the stream in accordance with the Encoding used and the specific character being read from the stream.</summary>
    /// <returns>A character read from the current stream.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <exception cref="T:System.ArgumentException">A surrogate character was read. </exception>
    /// <filterpriority>2</filterpriority>
    public char ReadChar()
    {
      return _binaryReader.ReadChar();
    }
    
    /// <summary>Reads the specified number of characters from the current stream, returns the data in a character array, and advances the current position in accordance with the Encoding used and the specific character being read from the stream.</summary>
    /// <returns>A character array containing data read from the underlying stream. This might be less than the number of characters requested if the end of the stream is reached.</returns>
    /// <param name="count">The number of characters to read. </param>
    /// <exception cref="T:System.ArgumentException">The number of decoded characters to read is greater than <paramref name="count" />. This can happen if a Unicode decoder returns fallback characters or a surrogate pair.</exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="count" /> is negative. </exception>
    /// <filterpriority>2</filterpriority>
    public char[] ReadChars(int count)
    {
      return _binaryReader.ReadChars(count);
    }
    
    /// <summary>Reads a decimal value from the current stream and advances the current position of the stream by sixteen bytes.</summary>
    /// <returns>A decimal value read from the current stream.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public decimal ReadDecimal()
    {
      return _binaryReader.ReadDecimal();
    }
    
    /// <summary>Reads an 8-byte floating point value from the current stream and advances the current position of the stream by eight bytes.</summary>
    /// <returns>An 8-byte floating point value read from the current stream.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public double ReadDouble()
    {
      return _binaryReader.ReadDouble();
    }
    
    /// <summary>Reads a 2-byte signed integer from the current stream and advances the current position of the stream by two bytes.</summary>
    /// <returns>A 2-byte signed integer read from the current stream.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public short ReadInt16()
    {
      return _binaryReader.ReadInt16();
    }
    
    /// <summary>Reads a 4-byte signed integer from the current stream and advances the current position of the stream by four bytes.</summary>
    /// <returns>A 4-byte signed integer read from the current stream.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public int ReadInt32()
    {
      return _binaryReader.ReadInt32();
    }
    
    /// <summary>Reads an 8-byte signed integer from the current stream and advances the current position of the stream by eight bytes.</summary>
    /// <returns>An 8-byte signed integer read from the current stream.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public long ReadInt64()
    {
      return _binaryReader.ReadInt64();
    }
    
    /// <summary>Reads a signed byte from this stream and advances the current position of the stream by one byte.</summary>
    /// <returns>A signed byte read from the current stream.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public sbyte ReadSByte()
    {
      return _binaryReader.ReadSByte();
    }
    
    /// <summary>Reads a 4-byte floating point value from the current stream and advances the current position of the stream by four bytes.</summary>
    /// <returns>A 4-byte floating point value read from the current stream.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public float ReadSingle()
    {
      return _binaryReader.ReadSingle();
    }
    
    /// <summary>Reads a string from the current stream. The string is prefixed with the length, encoded as an integer seven bits at a time.</summary>
    /// <returns>The string being read.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public string ReadString()
    {
      return _binaryReader.ReadString();
    }
    
    /// <summary>Reads a 2-byte unsigned integer from the current stream using little-endian encoding and advances the position of the stream by two bytes.</summary>
    /// <returns>A 2-byte unsigned integer read from this stream.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public ushort ReadUInt16()
    {
      return _binaryReader.ReadUInt16();
    }
    
    /// <summary>Reads a 4-byte unsigned integer from the current stream and advances the position of the stream by four bytes.</summary>
    /// <returns>A 4-byte unsigned integer read from this stream.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <filterpriority>2</filterpriority>
    public uint ReadUInt32()
    {
      return _binaryReader.ReadUInt32();
    }
    
    /// <summary>Reads an 8-byte unsigned integer from the current stream and advances the position of the stream by eight bytes.</summary>
    /// <returns>An 8-byte unsigned integer read from this stream.</returns>
    /// <exception cref="T:System.IO.EndOfStreamException">The end of the stream is reached. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurs. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <filterpriority>2</filterpriority>
    public ulong ReadUInt64()
    {
      return _binaryReader.ReadUInt64();
    }
    
    protected virtual void Dispose(bool disposing)
    {
      if (disposing)
      {
        _binaryReader.Dispose();
      }
    }
    
    public void Dispose()
    {
      this.Dispose(true);
      System.GC.SuppressFinalize(this);
    }
  }
}
