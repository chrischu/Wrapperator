//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Wrapperator.Wrappers
{
  
  
  /// <summary>Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</summary>
  /// <filterpriority>1</filterpriority>
  public class TypeStaticWrapper : Wrapperator.Interfaces.ITypeStatic
  {
    
    internal TypeStaticWrapper()
    {
    }
    
    public System.Reflection.Binder DefaultBinder
    {
      get
      {
        return System.Type.DefaultBinder;
      }
    }
    
    /// <summary>Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found. The type is loaded for reflection only, not for execution.</summary>
    /// <returns>The type with the specified name, if found; otherwise, null. If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether null is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />. See the Exceptions section.</returns>
    /// <param name="typeName">The assembly-qualified name of the <see cref="T:System.Type" /> to get. </param>
    /// <param name="throwIfNotFound">true to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; false to return null if the type cannot be found. Specifying false also suppresses some other exception conditions, but not all of them. See the Exceptions section.</param>
    /// <param name="ignoreCase">true to perform a case-insensitive search for <paramref name="typeName" />; false to perform a case-sensitive search for <paramref name="typeName" />. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="typeName" /> is null. </exception>
    /// <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception. </exception>
    /// <exception cref="T:System.TypeLoadException">
    ///  <paramref name="throwIfNotFound" /> is true and the type is not found. -or-<paramref name="throwIfNotFound" /> is true and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.-or-<paramref name="throwIfNotFound" /> is true and <paramref name="typeName" /> is an empty string.-or-<paramref name="throwIfNotFound" /> is true and <paramref name="typeName" /> represents an array type with an invalid size. -or-<paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="typeName" /> does not include the assembly name.-or-<paramref name="throwIfNotFound" /> is true and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,*,]".-or-<paramref name="typeName" /> represents a generic type that has a pointer type, a ByRef type, or <see cref="T:System.Void" /> as one of its type arguments.-or-<paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.-or-<paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</exception>
    /// <exception cref="T:System.IO.FileNotFoundException">
    ///  <paramref name="throwIfNotFound" /> is true and the assembly or one of its dependencies was not found. </exception>
    /// <exception cref="T:System.IO.FileLoadException">The assembly or one of its dependencies was found, but could not be loaded. </exception>
    /// <exception cref="T:System.BadImageFormatException">The assembly or one of its dependencies is not valid. -or-The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</exception>
    /// <filterpriority>1</filterpriority>
    public Wrapperator.Interfaces.IType ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase)
    {
      return new Wrapperator.Wrappers.TypeWrapper(System.Type.ReflectionOnlyGetType(typeName, throwIfNotFound, ignoreCase));
    }
    
    /// <summary>Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</summary>
    /// <returns>The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, null.</returns>
    /// <param name="progID">The ProgID of the type to get. </param>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="progID" /> is null. </exception>
    /// <filterpriority>1</filterpriority>
    public Wrapperator.Interfaces.IType GetTypeFromProgID(string progID)
    {
      return new Wrapperator.Wrappers.TypeWrapper(System.Type.GetTypeFromProgID(progID));
    }
    
    /// <summary>Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</summary>
    /// <returns>The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, null.</returns>
    /// <param name="progID">The ProgID of the type to get. </param>
    /// <param name="throwOnError">true to throw any exception that occurs.-or- false to ignore any exception that occurs. </param>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="progID" /> is null. </exception>
    /// <exception cref="T:System.Runtime.InteropServices.COMException">The specified ProgID is not registered. </exception>
    /// <filterpriority>1</filterpriority>
    public Wrapperator.Interfaces.IType GetTypeFromProgID(string progID, bool throwOnError)
    {
      return new Wrapperator.Wrappers.TypeWrapper(System.Type.GetTypeFromProgID(progID, throwOnError));
    }
    
    /// <summary>Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</summary>
    /// <returns>The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, null.</returns>
    /// <param name="progID">The progID of the type to get. </param>
    /// <param name="server">The server from which to load the type. If the server name is null, this method automatically reverts to the local machine. </param>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="prodID" /> is null. </exception>
    /// <filterpriority>1</filterpriority>
    public Wrapperator.Interfaces.IType GetTypeFromProgID(string progID, string server)
    {
      return new Wrapperator.Wrappers.TypeWrapper(System.Type.GetTypeFromProgID(progID, server));
    }
    
    /// <summary>Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</summary>
    /// <returns>The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, null.</returns>
    /// <param name="progID">The progID of the <see cref="T:System.Type" /> to get. </param>
    /// <param name="server">The server from which to load the type. If the server name is null, this method automatically reverts to the local machine. </param>
    /// <param name="throwOnError">true to throw any exception that occurs.-or- false to ignore any exception that occurs. </param>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="progID" /> is null. </exception>
    /// <exception cref="T:System.Runtime.InteropServices.COMException">The specified progID is not registered. </exception>
    /// <filterpriority>1</filterpriority>
    public Wrapperator.Interfaces.IType GetTypeFromProgID(string progID, string server, bool throwOnError)
    {
      return new Wrapperator.Wrappers.TypeWrapper(System.Type.GetTypeFromProgID(progID, server, throwOnError));
    }
    
    /// <summary>Gets the type associated with the specified class identifier (CLSID).</summary>
    /// <returns>System.__ComObject regardless of whether the CLSID is valid.</returns>
    /// <param name="clsid">The CLSID of the type to get. </param>
    /// <filterpriority>1</filterpriority>
    public Wrapperator.Interfaces.IType GetTypeFromCLSID(System.Guid clsid)
    {
      return new Wrapperator.Wrappers.TypeWrapper(System.Type.GetTypeFromCLSID(clsid));
    }
    
    /// <summary>Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</summary>
    /// <returns>System.__ComObject regardless of whether the CLSID is valid.</returns>
    /// <param name="clsid">The CLSID of the type to get. </param>
    /// <param name="throwOnError">true to throw any exception that occurs.-or- false to ignore any exception that occurs. </param>
    /// <filterpriority>1</filterpriority>
    public Wrapperator.Interfaces.IType GetTypeFromCLSID(System.Guid clsid, bool throwOnError)
    {
      return new Wrapperator.Wrappers.TypeWrapper(System.Type.GetTypeFromCLSID(clsid, throwOnError));
    }
    
    /// <summary>Gets the type associated with the specified class identifier (CLSID) from the specified server.</summary>
    /// <returns>System.__ComObject regardless of whether the CLSID is valid.</returns>
    /// <param name="clsid">The CLSID of the type to get. </param>
    /// <param name="server">The server from which to load the type. If the server name is null, this method automatically reverts to the local machine. </param>
    /// <filterpriority>1</filterpriority>
    public Wrapperator.Interfaces.IType GetTypeFromCLSID(System.Guid clsid, string server)
    {
      return new Wrapperator.Wrappers.TypeWrapper(System.Type.GetTypeFromCLSID(clsid, server));
    }
    
    /// <summary>Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</summary>
    /// <returns>System.__ComObject regardless of whether the CLSID is valid.</returns>
    /// <param name="clsid">The CLSID of the type to get. </param>
    /// <param name="server">The server from which to load the type. If the server name is null, this method automatically reverts to the local machine. </param>
    /// <param name="throwOnError">true to throw any exception that occurs.-or- false to ignore any exception that occurs. </param>
    /// <filterpriority>1</filterpriority>
    public Wrapperator.Interfaces.IType GetTypeFromCLSID(System.Guid clsid, string server, bool throwOnError)
    {
      return new Wrapperator.Wrappers.TypeWrapper(System.Type.GetTypeFromCLSID(clsid, server, throwOnError));
    }
    
    /// <summary>Gets the underlying type code of the specified <see cref="T:System.Type" />.</summary>
    /// <returns>The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is null.</returns>
    /// <param name="type">The type whose underlying type code to get. </param>
    /// <filterpriority>1</filterpriority>
    public System.TypeCode GetTypeCode(Wrapperator.Interfaces.IType type)
    {
      return System.Type.GetTypeCode(type == null ? default(System.Type) : type._Type);
    }
    
    /// <summary>Gets the handle for the <see cref="T:System.Type" /> of a specified object.</summary>
    /// <returns>The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</returns>
    /// <param name="o">The object for which to get the type handle. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="o" /> is null.</exception>
    /// <filterpriority>1</filterpriority>
    public System.RuntimeTypeHandle GetTypeHandle(object o)
    {
      return System.Type.GetTypeHandle(o);
    }
    
    /// <summary>Gets the type referenced by the specified type handle.</summary>
    /// <returns>The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or null if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is null.</returns>
    /// <param name="handle">The object that refers to the type. </param>
    /// <exception cref="T:System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception. </exception>
    /// <filterpriority>1</filterpriority>
    public Wrapperator.Interfaces.IType GetTypeFromHandle(System.RuntimeTypeHandle handle)
    {
      return new Wrapperator.Wrappers.TypeWrapper(System.Type.GetTypeFromHandle(handle));
    }
    
    /// <summary>Gets the types of the objects in the specified array.</summary>
    /// <returns>An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</returns>
    /// <param name="args">An array of objects whose types to determine. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="args" /> is null. </exception>
    /// <exception cref="T:System.Reflection.TargetInvocationException">The class initializers are invoked and at least one throws an exception. </exception>
    /// <filterpriority>1</filterpriority>
    public System.Type[] GetTypeArray(object[] args)
    {
      return System.Type.GetTypeArray(args);
    }
  }
}
