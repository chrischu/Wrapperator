//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Wrapperator.Interfaces
{
  
  
  /// <summary>Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</summary>
  /// <filterpriority>1</filterpriority>
  public interface IType
  {
    
    System.Reflection.MemberTypes MemberType
    {
      get;
    }
    
    Wrapperator.Interfaces.IType DeclaringType
    {
      get;
    }
    
    System.Reflection.MethodBase DeclaringMethod
    {
      get;
    }
    
    Wrapperator.Interfaces.IType ReflectedType
    {
      get;
    }
    
    System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute
    {
      get;
    }
    
    System.Guid GUID
    {
      get;
    }
    
    System.Reflection.Module Module
    {
      get;
    }
    
    Wrapperator.Interfaces.Reflection.IAssembly Assembly
    {
      get;
    }
    
    System.RuntimeTypeHandle TypeHandle
    {
      get;
    }
    
    string FullName
    {
      get;
    }
    
    string Namespace
    {
      get;
    }
    
    string AssemblyQualifiedName
    {
      get;
    }
    
    Wrapperator.Interfaces.IType BaseType
    {
      get;
    }
    
    System.Reflection.ConstructorInfo TypeInitializer
    {
      get;
    }
    
    bool IsNested
    {
      get;
    }
    
    System.Reflection.TypeAttributes Attributes
    {
      get;
    }
    
    System.Reflection.GenericParameterAttributes GenericParameterAttributes
    {
      get;
    }
    
    bool IsVisible
    {
      get;
    }
    
    bool IsNotPublic
    {
      get;
    }
    
    bool IsPublic
    {
      get;
    }
    
    bool IsNestedPublic
    {
      get;
    }
    
    bool IsNestedPrivate
    {
      get;
    }
    
    bool IsNestedFamily
    {
      get;
    }
    
    bool IsNestedAssembly
    {
      get;
    }
    
    bool IsNestedFamANDAssem
    {
      get;
    }
    
    bool IsNestedFamORAssem
    {
      get;
    }
    
    bool IsAutoLayout
    {
      get;
    }
    
    bool IsLayoutSequential
    {
      get;
    }
    
    bool IsExplicitLayout
    {
      get;
    }
    
    bool IsClass
    {
      get;
    }
    
    bool IsInterface
    {
      get;
    }
    
    bool IsValueType
    {
      get;
    }
    
    bool IsAbstract
    {
      get;
    }
    
    bool IsSealed
    {
      get;
    }
    
    bool IsEnum
    {
      get;
    }
    
    bool IsSpecialName
    {
      get;
    }
    
    bool IsImport
    {
      get;
    }
    
    bool IsSerializable
    {
      get;
    }
    
    bool IsAnsiClass
    {
      get;
    }
    
    bool IsUnicodeClass
    {
      get;
    }
    
    bool IsAutoClass
    {
      get;
    }
    
    bool IsArray
    {
      get;
    }
    
    bool IsGenericType
    {
      get;
    }
    
    bool IsGenericTypeDefinition
    {
      get;
    }
    
    bool IsConstructedGenericType
    {
      get;
    }
    
    bool IsGenericParameter
    {
      get;
    }
    
    int GenericParameterPosition
    {
      get;
    }
    
    bool ContainsGenericParameters
    {
      get;
    }
    
    bool IsByRef
    {
      get;
    }
    
    bool IsPointer
    {
      get;
    }
    
    bool IsPrimitive
    {
      get;
    }
    
    bool IsCOMObject
    {
      get;
    }
    
    bool HasElementType
    {
      get;
    }
    
    bool IsContextful
    {
      get;
    }
    
    bool IsMarshalByRef
    {
      get;
    }
    
    System.Type[] GenericTypeArguments
    {
      get;
    }
    
    bool IsSecurityCritical
    {
      get;
    }
    
    bool IsSecuritySafeCritical
    {
      get;
    }
    
    bool IsSecurityTransparent
    {
      get;
    }
    
    Wrapperator.Interfaces.IType UnderlyingSystemType
    {
      get;
    }
    
    string Name
    {
      get;
    }
    
    System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> CustomAttributes
    {
      get;
    }
    
    int MetadataToken
    {
      get;
    }
    
    /// <summary>Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</summary>
    /// <returns>A <see cref="T:System.Type" /> object that represents a pointer to the current type.</returns>
    /// <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class.</exception>
    /// <exception cref="T:System.TypeLoadException">The current type is <see cref="T:System.TypedReference" />.-or-The current type is a ByRef type. That is, <see cref="P:System.Type.IsByRef" /> returns true. </exception>
    /// <filterpriority>2</filterpriority>
    Wrapperator.Interfaces.IType MakePointerType();
    
    /// <summary>Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a ref parameter (ByRef parameter in Visual Basic).</summary>
    /// <returns>A <see cref="T:System.Type" /> object that represents the current type when passed as a ref parameter (ByRef parameter in Visual Basic).</returns>
    /// <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class.</exception>
    /// <exception cref="T:System.TypeLoadException">The current type is <see cref="T:System.TypedReference" />.-or-The current type is a ByRef type. That is, <see cref="P:System.Type.IsByRef" /> returns true. </exception>
    /// <filterpriority>2</filterpriority>
    Wrapperator.Interfaces.IType MakeByRefType();
    
    /// <summary>Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</summary>
    /// <returns>A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</returns>
    /// <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class. Derived classes must provide an implementation.</exception>
    /// <exception cref="T:System.TypeLoadException">The current type is <see cref="T:System.TypedReference" />.-or-The current type is a ByRef type. That is, <see cref="P:System.Type.IsByRef" /> returns true. </exception>
    /// <filterpriority>2</filterpriority>
    Wrapperator.Interfaces.IType MakeArrayType();
    
    /// <summary>Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</summary>
    /// <returns>An object representing an array of the current type, with the specified number of dimensions.</returns>
    /// <param name="rank">The number of dimensions for the array. This number must be less than or equal to 32.</param>
    /// <exception cref="T:System.IndexOutOfRangeException">
    ///  <paramref name="rank" /> is invalid. For example, 0 or negative.</exception>
    /// <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class.</exception>
    /// <exception cref="T:System.TypeLoadException">The current type is <see cref="T:System.TypedReference" />.-or-The current type is a ByRef type. That is, <see cref="P:System.Type.IsByRef" /> returns true. -or-<paramref name="rank" /> is greater than 32.</exception>
    /// <filterpriority>2</filterpriority>
    Wrapperator.Interfaces.IType MakeArrayType(int rank);
    
    /// <summary>When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</summary>
    /// <returns>An object representing the return value of the invoked member.</returns>
    /// <param name="name">The string containing the name of the constructor, method, property, or field member to invoke.-or- An empty string ("") to invoke the default member. -or-For IDispatch members, a string representing the DispID, for example "[DispID=3]".</param>
    /// <param name="invokeAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted. The access can be one of the BindingFlags such as Public, NonPublic, Private, InvokeMethod, GetField, and so on. The type of lookup need not be specified. If the type of lookup is omitted, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static are used. </param>
    /// <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.-or- A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />. Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</param>
    /// <param name="target">The object on which to invoke the specified member. </param>
    /// <param name="args">An array containing the arguments to pass to the member to invoke. </param>
    /// <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="args" /> array. A parameter's associated attributes are stored in the member's signature. The default binder processes this parameter only when calling a COM component. </param>
    /// <param name="culture">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.-or- A null reference (Nothing in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />. </param>
    /// <param name="namedParameters">An array containing the names of the parameters to which the values in the <paramref name="args" /> array are passed. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="invokeAttr" /> does not contain CreateInstance and <paramref name="name" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.-or- <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.-or- <paramref name="invokeAttr" /> does not contain one of the following binding flags: InvokeMethod, CreateInstance, GetField, SetField, GetProperty, or SetProperty.-or- <paramref name="invokeAttr" /> contains CreateInstance combined with InvokeMethod, GetField, SetField, GetProperty, or SetProperty.-or- <paramref name="invokeAttr" /> contains both GetField and SetField.-or- <paramref name="invokeAttr" /> contains both GetProperty and SetProperty.-or- <paramref name="invokeAttr" /> contains InvokeMethod combined with SetField or SetProperty.-or- <paramref name="invokeAttr" /> contains SetField and <paramref name="args" /> has more than one element.-or- The named parameter array is larger than the argument array.-or- This method is called on a COM object and one of the following binding flags was not passed in: BindingFlags.InvokeMethod, BindingFlags.GetProperty, BindingFlags.SetProperty, BindingFlags.PutDispProperty, or BindingFlags.PutRefDispProperty.-or- One of the named parameter arrays contains a string that is null. </exception>
    /// <exception cref="T:System.MethodAccessException">The specified member is a class initializer. </exception>
    /// <exception cref="T:System.MissingFieldException">The field or property cannot be found. </exception>
    /// <exception cref="T:System.MissingMethodException">No method can be found that matches the arguments in <paramref name="args" />.-or- No member can be found that has the argument names supplied in <paramref name="namedParameters" />.-or- The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns true. </exception>
    /// <exception cref="T:System.Reflection.TargetException">The specified member cannot be invoked on <paramref name="target" />. </exception>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matches the binding criteria. </exception>
    /// <exception cref="T:System.InvalidOperationException">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters. That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns true.</exception>
    /// <filterpriority>2</filterpriority>
    object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
    
    /// <summary>Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</summary>
    /// <returns>An object representing the return value of the invoked member.</returns>
    /// <param name="name">The string containing the name of the constructor, method, property, or field member to invoke.-or- An empty string ("") to invoke the default member. -or-For IDispatch members, a string representing the DispID, for example "[DispID=3]".</param>
    /// <param name="invokeAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted. The access can be one of the BindingFlags such as Public, NonPublic, Private, InvokeMethod, GetField, and so on. The type of lookup need not be specified. If the type of lookup is omitted, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static are used. </param>
    /// <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.-or- A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />. Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</param>
    /// <param name="target">The object on which to invoke the specified member. </param>
    /// <param name="args">An array containing the arguments to pass to the member to invoke. </param>
    /// <param name="culture">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.-or- A null reference (Nothing in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="invokeAttr" /> does not contain CreateInstance and <paramref name="name" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute. -or- <paramref name="invokeAttr" /> does not contain one of the following binding flags: InvokeMethod, CreateInstance, GetField, SetField, GetProperty, or SetProperty.-or- <paramref name="invokeAttr" /> contains CreateInstance combined with InvokeMethod, GetField, SetField, GetProperty, or SetProperty.-or- <paramref name="invokeAttr" /> contains both GetField and SetField.-or- <paramref name="invokeAttr" /> contains both GetProperty and SetProperty.-or- <paramref name="invokeAttr" /> contains InvokeMethod combined with SetField or SetProperty.-or- <paramref name="invokeAttr" /> contains SetField and <paramref name="args" /> has more than one element.-or- This method is called on a COM object and one of the following binding flags was not passed in: BindingFlags.InvokeMethod, BindingFlags.GetProperty, BindingFlags.SetProperty, BindingFlags.PutDispProperty, or BindingFlags.PutRefDispProperty.-or- One of the named parameter arrays contains a string that is null. </exception>
    /// <exception cref="T:System.MethodAccessException">The specified member is a class initializer. </exception>
    /// <exception cref="T:System.MissingFieldException">The field or property cannot be found. </exception>
    /// <exception cref="T:System.MissingMethodException">No method can be found that matches the arguments in <paramref name="args" />.-or- The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns true. </exception>
    /// <exception cref="T:System.Reflection.TargetException">The specified member cannot be invoked on <paramref name="target" />. </exception>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matches the binding criteria. </exception>
    /// <exception cref="T:System.InvalidOperationException">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters. That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns true.</exception>
    /// <filterpriority>2</filterpriority>
    object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);
    
    /// <summary>Invokes the specified member, using the specified binding constraints and matching the specified argument list.</summary>
    /// <returns>An object representing the return value of the invoked member.</returns>
    /// <param name="name">The string containing the name of the constructor, method, property, or field member to invoke.-or- An empty string ("") to invoke the default member. -or-For IDispatch members, a string representing the DispID, for example "[DispID=3]".</param>
    /// <param name="invokeAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted. The access can be one of the BindingFlags such as Public, NonPublic, Private, InvokeMethod, GetField, and so on. The type of lookup need not be specified. If the type of lookup is omitted, BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static are used. </param>
    /// <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.-or- A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />. Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</param>
    /// <param name="target">The object on which to invoke the specified member. </param>
    /// <param name="args">An array containing the arguments to pass to the member to invoke. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="invokeAttr" /> does not contain CreateInstance and <paramref name="name" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute. -or- <paramref name="invokeAttr" /> does not contain one of the following binding flags: InvokeMethod, CreateInstance, GetField, SetField, GetProperty, or SetProperty. -or- <paramref name="invokeAttr" /> contains CreateInstance combined with InvokeMethod, GetField, SetField, GetProperty, or SetProperty.-or- <paramref name="invokeAttr" /> contains both GetField and SetField.-or- <paramref name="invokeAttr" /> contains both GetProperty and SetProperty.-or- <paramref name="invokeAttr" /> contains InvokeMethod combined with SetField or SetProperty.-or- <paramref name="invokeAttr" /> contains SetField and <paramref name="args" /> has more than one element.-or- This method is called on a COM object and one of the following binding flags was not passed in: BindingFlags.InvokeMethod, BindingFlags.GetProperty, BindingFlags.SetProperty, BindingFlags.PutDispProperty, or BindingFlags.PutRefDispProperty.-or- One of the named parameter arrays contains a string that is null. </exception>
    /// <exception cref="T:System.MethodAccessException">The specified member is a class initializer. </exception>
    /// <exception cref="T:System.MissingFieldException">The field or property cannot be found. </exception>
    /// <exception cref="T:System.MissingMethodException">No method can be found that matches the arguments in <paramref name="args" />.-or- The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns true. </exception>
    /// <exception cref="T:System.Reflection.TargetException">The specified member cannot be invoked on <paramref name="target" />. </exception>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method matches the binding criteria. </exception>
    /// <exception cref="T:System.NotSupportedException">The .NET Compact Framework does not currently support this method.</exception>
    /// <exception cref="T:System.InvalidOperationException">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters. That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns true.</exception>
    /// <filterpriority>2</filterpriority>
    object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);
    
    /// <summary>Gets the number of dimensions in an <see cref="T:System.Array" />.</summary>
    /// <returns>An <see cref="T:System.Int32" /> containing the number of dimensions in the current Type.</returns>
    /// <exception cref="T:System.NotSupportedException">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead. </exception>
    /// <exception cref="T:System.ArgumentException">The current Type is not an array. </exception>
    /// <filterpriority>2</filterpriority>
    int GetArrayRank();
    
    /// <summary>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</summary>
    /// <returns>An object representing the constructor that matches the specified requirements, if found; otherwise, null.</returns>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.-or- A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />. </param>
    /// <param name="callConvention">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up. </param>
    /// <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.-or- An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters. </param>
    /// <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. The default binder does not process this parameter. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="types" /> is null.-or- One of the elements in <paramref name="types" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="types" /> is multidimensional.-or- <paramref name="modifiers" /> is multidimensional.-or- <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
    
    /// <summary>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</summary>
    /// <returns>A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, null.</returns>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.-or- A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />. </param>
    /// <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.-or- An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.-or- <see cref="F:System.Type.EmptyTypes" />. </param>
    /// <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array. The default binder does not process this parameter. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="types" /> is null.-or- One of the elements in <paramref name="types" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="types" /> is multidimensional.-or- <paramref name="modifiers" /> is multidimensional.-or- <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
    
    /// <summary>Searches for a public instance constructor whose parameters match the types in the specified array.</summary>
    /// <returns>An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, null.</returns>
    /// <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.-or- An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters. Such an empty array is provided by the static field <see cref="F:System.Type.EmptyTypes" />. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="types" /> is null.-or- One of the elements in <paramref name="types" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="types" /> is multidimensional. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.ConstructorInfo GetConstructor(System.Type[] types);
    
    /// <summary>Returns all the public constructors defined for the current <see cref="T:System.Type" />.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor). If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</returns>
    /// <filterpriority>2</filterpriority>
    System.Reflection.ConstructorInfo[] GetConstructors();
    
    /// <summary>When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified BindingFlags.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined. Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</returns>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <filterpriority>2</filterpriority>
    System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</summary>
    /// <returns>An object representing the method that matches the specified requirements, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the method to get. </param>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.-or- A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />. </param>
    /// <param name="callConvention">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up. </param>
    /// <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.-or- An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters. </param>
    /// <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter. </param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and matching the specified binding constraints. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null.-or- <paramref name="types" /> is null.-or- One of the elements in <paramref name="types" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="types" /> is multidimensional.-or- <paramref name="modifiers" /> is multidimensional. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
    
    /// <summary>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</summary>
    /// <returns>An object representing the method that matches the specified requirements, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the method to get. </param>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.-or- A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />. </param>
    /// <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.-or- An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters. </param>
    /// <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.</param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and matching the specified binding constraints. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null.-or- <paramref name="types" /> is null.-or- One of the elements in <paramref name="types" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="types" /> is multidimensional.-or- <paramref name="modifiers" /> is multidimensional. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
    
    /// <summary>Searches for the specified public method whose parameters match the specified argument types and modifiers.</summary>
    /// <returns>An object representing the public method that matches the specified requirements, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the public method to get. </param>
    /// <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.-or- An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters. </param>
    /// <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.  </param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and specified parameters. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null.-or- <paramref name="types" /> is null.-or- One of the elements in <paramref name="types" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="types" /> is multidimensional.-or- <paramref name="modifiers" /> is multidimensional. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MethodInfo GetMethod(string name, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
    
    /// <summary>Searches for the specified public method whose parameters match the specified argument types.</summary>
    /// <returns>An object representing the public method whose parameters match the specified argument types, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the public method to get. </param>
    /// <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.-or- An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters. </param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and specified parameters. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null.-or- <paramref name="types" /> is null.-or- One of the elements in <paramref name="types" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="types" /> is multidimensional. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MethodInfo GetMethod(string name, System.Type[] types);
    
    /// <summary>Searches for the specified method, using the specified binding constraints.</summary>
    /// <returns>An object representing the method that matches the specified requirements, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the method to get. </param>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and matching the specified binding constraints. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Searches for the public method with the specified name.</summary>
    /// <returns>An object that represents the public method with the specified name, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the public method to get. </param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method is found with the specified name. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MethodInfo GetMethod(string name);
    
    /// <summary>Returns all the public methods of the current <see cref="T:System.Type" />.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.-or- An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</returns>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MethodInfo[] GetMethods();
    
    /// <summary>When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.-or- An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</returns>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Searches for the specified field, using the specified binding constraints.</summary>
    /// <returns>An object representing the field that matches the specified requirements, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the data field to get. </param>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Searches for the public field with the specified name.</summary>
    /// <returns>An object representing the public field with the specified name, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the data field to get. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <exception cref="T:System.NotSupportedException">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.FieldInfo GetField(string name);
    
    /// <summary>Returns all the public fields of the current <see cref="T:System.Type" />.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.-or- An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</returns>
    /// <filterpriority>2</filterpriority>
    System.Reflection.FieldInfo[] GetFields();
    
    /// <summary>When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.-or- An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</returns>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <filterpriority>2</filterpriority>
    System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Searches for the interface with the specified name.</summary>
    /// <returns>An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the interface to get. For generic interfaces, this is the mangled name.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments. </exception>
    /// <filterpriority>2</filterpriority>
    Wrapperator.Interfaces.IType GetInterface(string name);
    
    /// <summary>When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</summary>
    /// <returns>An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the interface to get. For generic interfaces, this is the mangled name.</param>
    /// <param name="ignoreCase">true to ignore the case of that part of <paramref name="name" /> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).-or- false to perform a case-sensitive search for all parts of <paramref name="name" />. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments. </exception>
    /// <filterpriority>2</filterpriority>
    Wrapperator.Interfaces.IType GetInterface(string name, bool ignoreCase);
    
    /// <summary>When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</summary>
    /// <returns>An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.-or- An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</returns>
    /// <exception cref="T:System.Reflection.TargetInvocationException">A static initializer is invoked and throws an exception. </exception>
    /// <filterpriority>2</filterpriority>
    System.Type[] GetInterfaces();
    
    /// <summary>Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</summary>
    /// <returns>An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array of type <see cref="T:System.Type" /> if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</returns>
    /// <param name="filter">The delegate that compares the interfaces against <paramref name="filterCriteria" />. </param>
    /// <param name="filterCriteria">The search criteria that determines whether an interface should be included in the returned array. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="filter" /> is null. </exception>
    /// <exception cref="T:System.Reflection.TargetInvocationException">A static initializer is invoked and throws an exception. </exception>
    /// <filterpriority>2</filterpriority>
    System.Type[] FindInterfaces(System.Reflection.TypeFilter filter, object filterCriteria);
    
    /// <summary>Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</summary>
    /// <returns>The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.EventInfo GetEvent(string name);
    
    /// <summary>When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</summary>
    /// <returns>The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />. </param>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.-or- An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</returns>
    /// <filterpriority>2</filterpriority>
    System.Reflection.EventInfo[] GetEvents();
    
    /// <summary>When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.-or- An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</returns>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <filterpriority>2</filterpriority>
    System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</summary>
    /// <returns>An object representing the property that matches the specified requirements, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the property to get. </param>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <param name="binder">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.-or- A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />. </param>
    /// <param name="returnType">The return type of the property. </param>
    /// <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.-or- An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed. </param>
    /// <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. The default binder does not process this parameter. </param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified binding constraints. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null.-or- <paramref name="types" /> is null.</exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="types" /> is multidimensional.-or- <paramref name="modifiers" /> is multidimensional.-or- <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length. </exception>
    /// <exception cref="T:System.NullReferenceException">An element of <paramref name="types" /> is null.</exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Wrapperator.Interfaces.IType returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
    
    /// <summary>Searches for the specified public property whose parameters match the specified argument types and modifiers.</summary>
    /// <returns>An object representing the public property that matches the specified requirements, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the public property to get. </param>
    /// <param name="returnType">The return type of the property. </param>
    /// <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.-or- An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed. </param>
    /// <param name="modifiers">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array. The default binder does not process this parameter. </param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified argument types and modifiers. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null.-or- <paramref name="types" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="types" /> is multidimensional.-or- <paramref name="modifiers" /> is multidimensional.-or- <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length. </exception>
    /// <exception cref="T:System.NullReferenceException">An element of <paramref name="types" /> is null.</exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.PropertyInfo GetProperty(string name, Wrapperator.Interfaces.IType returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
    
    /// <summary>Searches for the specified property, using the specified binding constraints.</summary>
    /// <returns>An object representing the property that matches the specified requirements, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the property to get. </param>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified binding constraints. See Remarks.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Searches for the specified public property whose parameters match the specified argument types.</summary>
    /// <returns>An object representing the public property whose parameters match the specified argument types, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the public property to get. </param>
    /// <param name="returnType">The return type of the property. </param>
    /// <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.-or- An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed. </param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified argument types. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null.-or- <paramref name="types" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="types" /> is multidimensional. </exception>
    /// <exception cref="T:System.NullReferenceException">An element of <paramref name="types" /> is null.</exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.PropertyInfo GetProperty(string name, Wrapperator.Interfaces.IType returnType, System.Type[] types);
    
    /// <summary>Searches for the specified public property whose parameters match the specified argument types.</summary>
    /// <returns>An object representing the public property whose parameters match the specified argument types, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the public property to get. </param>
    /// <param name="types">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.-or- An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed. </param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified argument types. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null.-or- <paramref name="types" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="types" /> is multidimensional. </exception>
    /// <exception cref="T:System.NullReferenceException">An element of <paramref name="types" /> is null.</exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.PropertyInfo GetProperty(string name, System.Type[] types);
    
    /// <summary>Searches for the public property with the specified name and return type.</summary>
    /// <returns>An object representing the public property with the specified name, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the public property to get. </param>
    /// <param name="returnType">The return type of the property. </param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null, or <paramref name="returnType" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.PropertyInfo GetProperty(string name, Wrapperator.Interfaces.IType returnType);
    
    /// <summary>Searches for the public property with the specified name.</summary>
    /// <returns>An object representing the public property with the specified name, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the public property to get. </param>
    /// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one property is found with the specified name. See Remarks.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.PropertyInfo GetProperty(string name);
    
    /// <summary>When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.-or- An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</returns>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <filterpriority>2</filterpriority>
    System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Returns all the public properties of the current <see cref="T:System.Type" />.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.-or- An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</returns>
    /// <filterpriority>2</filterpriority>
    System.Reflection.PropertyInfo[] GetProperties();
    
    /// <summary>Returns the public types nested in the current <see cref="T:System.Type" />.</summary>
    /// <returns>An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</returns>
    /// <filterpriority>2</filterpriority>
    System.Type[] GetNestedTypes();
    
    /// <summary>When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</summary>
    /// <returns>An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</returns>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <filterpriority>2</filterpriority>
    System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Searches for the public nested type with the specified name.</summary>
    /// <returns>An object representing the public nested type with the specified name, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the nested type to get. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    Wrapperator.Interfaces.IType GetNestedType(string name);
    
    /// <summary>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</summary>
    /// <returns>An object representing the nested type that matches the specified requirements, if found; otherwise, null.</returns>
    /// <param name="name">The string containing the name of the nested type to get. </param>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    Wrapperator.Interfaces.IType GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Searches for the public members with the specified name.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</returns>
    /// <param name="name">The string containing the name of the public members to get. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MemberInfo[] GetMember(string name);
    
    /// <summary>Searches for the specified members, using the specified binding constraints.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</returns>
    /// <param name="name">The string containing the name of the members to get. </param>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return an empty array. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Searches for the specified members of the specified member type, using the specified binding constraints.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</returns>
    /// <param name="name">The string containing the name of the members to get. </param>
    /// <param name="type">The value to search for. </param>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return an empty array. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="name" /> is null. </exception>
    /// <exception cref="T:System.NotSupportedException">A derived class must provide an implementation. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Returns all the public members of the current <see cref="T:System.Type" />.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.-or- An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</returns>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MemberInfo[] GetMembers();
    
    /// <summary>When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.-or- An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</returns>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), to return an empty array. </param>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
    
    /// <summary>Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</summary>
    /// <returns>An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.-or- An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</returns>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MemberInfo[] GetDefaultMembers();
    
    /// <summary>Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</summary>
    /// <returns>A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.-or- An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</returns>
    /// <param name="memberType">An object that indicates the type of member to search for. </param>
    /// <param name="bindingAttr">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.-or- Zero, to return null. </param>
    /// <param name="filter">The delegate that does the comparisons, returning true if the member currently being inspected matches the <paramref name="filterCriteria" /> and false otherwise. You can use the FilterAttribute, FilterName, and FilterNameIgnoreCase delegates supplied by this class. The first uses the fields of FieldAttributes, MethodAttributes, and MethodImplAttributes as search criteria, and the other two delegates use String objects as the search criteria. </param>
    /// <param name="filterCriteria">The search criteria that determines whether a member is returned in the array of MemberInfo objects.The fields of FieldAttributes, MethodAttributes, and MethodImplAttributes can be used in conjunction with the FilterAttribute delegate supplied by this class. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="filter" /> is null. </exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.MemberInfo[] FindMembers(System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);
    
    /// <summary>Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter. </summary>
    /// <returns>An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</returns>
    /// <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Type" /> object is not a generic type parameter. That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns false.</exception>
    /// <filterpriority>1</filterpriority>
    System.Type[] GetGenericParameterConstraints();
    
    /// <summary>Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</summary>
    /// <returns>A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</returns>
    /// <param name="typeArguments">An array of types to be substituted for the type parameters of the current generic type.</param>
    /// <exception cref="T:System.InvalidOperationException">The current type does not represent a generic type definition. That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns false. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="typeArguments" /> is null.-or- Any element of <paramref name="typeArguments" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.-or- Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type. -or- <paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns true), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns true), or <see cref="T:System.Void" />.</exception>
    /// <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class. Derived classes must provide an implementation.</exception>
    Wrapperator.Interfaces.IType MakeGenericType(System.Type[] typeArguments);
    
    /// <summary>When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</summary>
    /// <returns>The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or null if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</returns>
    /// <filterpriority>2</filterpriority>
    Wrapperator.Interfaces.IType GetElementType();
    
    /// <summary>Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type or the type parameters of a generic type definition.</summary>
    /// <returns>An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type. Returns an empty array if the current type is not a generic type.</returns>
    /// <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class. Derived classes must provide an implementation.</exception>
    /// <filterpriority>2</filterpriority>
    System.Type[] GetGenericArguments();
    
    /// <summary>Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</summary>
    /// <returns>A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</returns>
    /// <exception cref="T:System.InvalidOperationException">The current type is not a generic type.  That is, <see cref="P:System.Type.IsGenericType" /> returns false. </exception>
    /// <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class. Derived classes must provide an implementation.</exception>
    /// <filterpriority>2</filterpriority>
    Wrapperator.Interfaces.IType GetGenericTypeDefinition();
    
    /// <summary>Returns the names of the members of the current enumeration type.</summary>
    /// <returns>An array that contains the names of the members of the enumeration.</returns>
    /// <exception cref="T:System.ArgumentException">The current type is not an enumeration.</exception>
    string[] GetEnumNames();
    
    /// <summary>Returns an array of the values of the constants in the current enumeration type.</summary>
    /// <returns>An array that contains the values. The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</returns>
    /// <exception cref="T:System.ArgumentException">The current type is not an enumeration.</exception>
    System.Array GetEnumValues();
    
    /// <summary>Returns the underlying type of the current enumeration type. </summary>
    /// <returns>The underlying type of the current enumeration.</returns>
    /// <exception cref="T:System.ArgumentException">The current type is not an enumeration.-or-The enumeration type is not valid, because it contains more than one instance field.</exception>
    Wrapperator.Interfaces.IType GetEnumUnderlyingType();
    
    /// <summary>Returns a value that indicates whether the specified value exists in the current enumeration type.</summary>
    /// <returns>true if the specified value is a member of the current enumeration type; otherwise, false.</returns>
    /// <param name="value">The value to be tested.</param>
    /// <exception cref="T:System.ArgumentException">The current type is not an enumeration.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="value" /> is null.</exception>
    /// <exception cref="T:System.InvalidOperationException">
    ///  <paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</exception>
    bool IsEnumDefined(object value);
    
    /// <summary>Returns the name of the constant that has the specified value, for the current enumeration type.</summary>
    /// <returns>The name of the member of the current enumeration type that has the specified value, or null if no such constant is found.</returns>
    /// <param name="value">The value whose name is to be retrieved.</param>
    /// <exception cref="T:System.ArgumentException">The current type is not an enumeration.-or-<paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="value" /> is null.</exception>
    string GetEnumName(object value);
    
    /// <summary>Determines whether the class represented by the current <see cref="T:System.Type" /> derives from the class represented by the specified <see cref="T:System.Type" />.</summary>
    /// <returns>true if the Type represented by the <paramref name="c" /> parameter and the current Type represent classes, and the class represented by the current Type derives from the class represented by <paramref name="c" />; otherwise, false. This method also returns false if <paramref name="c" /> and the current Type represent the same class.</returns>
    /// <param name="c">The type to compare with the current type. </param>
    /// <exception cref="T:System.ArgumentNullException">The <paramref name="c" /> parameter is null. </exception>
    /// <filterpriority>2</filterpriority>
    bool IsSubclassOf(Wrapperator.Interfaces.IType c);
    
    /// <summary>Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</summary>
    /// <returns>true if the current Type is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current Type is an interface that <paramref name="o" /> supports. false if neither of these conditions is the case, or if <paramref name="o" /> is null, or if the current Type is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns true).</returns>
    /// <param name="o">The object to compare with the current type. </param>
    /// <filterpriority>2</filterpriority>
    bool IsInstanceOfType(object o);
    
    /// <summary>Determines whether an instance of the current <see cref="T:System.Type" /> can be assigned from an instance of the specified Type.</summary>
    /// <returns>true if <paramref name="c" /> and the current Type represent the same type, or if the current Type is in the inheritance hierarchy of <paramref name="c" />, or if the current Type is an interface that <paramref name="c" /> implements, or if <paramref name="c" /> is a generic type parameter and the current Type represents one of the constraints of <paramref name="c" />, or if <paramref name="c" /> represents a value type and the current Type represents Nullable&lt;c&gt; (Nullable(Of c) in Visual Basic). false if none of these conditions are true, or if <paramref name="c" /> is null.</returns>
    /// <param name="c">The type to compare with the current type. </param>
    /// <filterpriority>2</filterpriority>
    bool IsAssignableFrom(Wrapperator.Interfaces.IType c);
    
    /// <summary>Determines whether two COM types have the same identity and are eligible for type equivalence.</summary>
    /// <returns>true if the COM types are equivalent; otherwise, false. This method also returns false if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</returns>
    /// <param name="other">The COM type that is tested for equivalence with the current type.</param>
    bool IsEquivalentTo(Wrapperator.Interfaces.IType other);
    
    /// <summary>Returns an interface mapping for the specified interface type.</summary>
    /// <returns>An object that represents the interface mapping for <paramref name="interfaceType" />.</returns>
    /// <param name="interfaceType">The interface type to retrieve a mapping for. </param>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="interfaceType" /> is not implemented by the current type. -or-The <paramref name="interfaceType" /> parameter does not refer to an interface. -or-<paramref name="interfaceType" /> is a generic interface, and the current type is an array type. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="interfaceType" /> is null. </exception>
    /// <exception cref="T:System.InvalidOperationException">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is true. </exception>
    /// <exception cref="T:System.NotSupportedException">The invoked method is not supported in the base class. Derived classes must provide an implementation.</exception>
    /// <filterpriority>2</filterpriority>
    System.Reflection.InterfaceMapping GetInterfaceMap(Wrapperator.Interfaces.IType interfaceType);
    
    /// <summary>When overridden in a derived class, returns an array of all custom attributes applied to this member. </summary>
    /// <returns>An array that contains all the custom attributes applied to this member, or an array with zero elements if no attributes are defined.</returns>
    /// <param name="inherit">true to search this member's inheritance chain to find the attributes; otherwise, false. This parameter is ignored for properties and events; see Remarks.</param>
    /// <exception cref="T:System.InvalidOperationException">This member belongs to a type that is loaded into the reflection-only context. See How to: Load Assemblies into the Reflection-Only Context.</exception>
    /// <exception cref="T:System.TypeLoadException">A custom attribute type could not be loaded. </exception>
    object[] GetCustomAttributes(bool inherit);
    
    /// <summary>When overridden in a derived class, returns an array of custom attributes applied to this member and identified by <see cref="T:System.Type" />.</summary>
    /// <returns>An array of custom attributes applied to this member, or an array with zero elements if no attributes assignable to <paramref name="attributeType" /> have been applied.</returns>
    /// <param name="attributeType">The type of attribute to search for. Only attributes that are assignable to this type are returned. </param>
    /// <param name="inherit">true to search this member's inheritance chain to find the attributes; otherwise, false. This parameter is ignored for properties and events; see Remarks. </param>
    /// <exception cref="T:System.TypeLoadException">A custom attribute type cannot be loaded. </exception>
    /// <exception cref="T:System.ArgumentNullException">If <paramref name="attributeType" /> is null.</exception>
    /// <exception cref="T:System.InvalidOperationException">This member belongs to a type that is loaded into the reflection-only context. See How to: Load Assemblies into the Reflection-Only Context.</exception>
    object[] GetCustomAttributes(Wrapperator.Interfaces.IType attributeType, bool inherit);
    
    /// <summary>When overridden in a derived class, indicates whether one or more attributes of the specified type or of its derived types is applied to this member.</summary>
    /// <returns>true if one or more instances of <paramref name="attributeType" /> or any of its derived types is applied to this member; otherwise, false.</returns>
    /// <param name="attributeType">The type of custom attribute to search for. The search includes derived types. </param>
    /// <param name="inherit">true to search this member's inheritance chain to find the attributes; otherwise, false. This parameter is ignored for properties and events; see Remarks.</param>
    bool IsDefined(Wrapperator.Interfaces.IType attributeType, bool inherit);
    
    /// <summary>Returns a list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the target member.</summary>
    /// <returns>A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the target member.</returns>
    System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
  }
}
