//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Wrapperator.Interfaces.IO
{
  
  
  /// <summary>Exposes a <see cref="T:System.IO.Stream" /> around a file, supporting both synchronous and asynchronous read and write operations.</summary>
  /// <filterpriority>1</filterpriority>
  public partial interface IFileStream : System.IDisposable
  {
    
    /// <summary>Begins an asynchronous read operation. (Consider using <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead; see the Remarks section.)</summary>
    /// <returns>An object that references the asynchronous read.</returns>
    /// <param name="array">The buffer to read data into. </param>
    /// <param name="offset">The byte offset in <paramref name="array" /> at which to begin reading. </param>
    /// <param name="numBytes">The maximum number of bytes to read. </param>
    /// <param name="userCallback">The method to be called when the asynchronous read operation is completed. </param>
    /// <param name="stateObject">A user-provided object that distinguishes this particular asynchronous read request from other requests. </param>
    /// <exception cref="T:System.ArgumentException">The array length minus <paramref name="offset" /> is less than <paramref name="numBytes" />. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="array" /> is null. </exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="offset" /> or <paramref name="numBytes" /> is negative. </exception>
    /// <exception cref="T:System.IO.IOException">An asynchronous read was attempted past the end of the file. </exception>
    /// <filterpriority>2</filterpriority>
    System.IAsyncResult BeginRead(byte[] array, int offset, int numBytes, System.AsyncCallback userCallback, object stateObject);
    
    /// <summary>Begins an asynchronous write operation. (Consider using <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead; see the Remarks section.)</summary>
    /// <returns>An object that references the asynchronous write.</returns>
    /// <param name="array">The buffer containing data to write to the current stream.</param>
    /// <param name="offset">The zero-based byte offset in <paramref name="array" /> at which to begin copying bytes to the current stream.</param>
    /// <param name="numBytes">The maximum number of bytes to write. </param>
    /// <param name="userCallback">The method to be called when the asynchronous write operation is completed. </param>
    /// <param name="stateObject">A user-provided object that distinguishes this particular asynchronous write request from other requests. </param>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="array" /> length minus <paramref name="offset" /> is less than <paramref name="numBytes" />. </exception>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="array" /> is null. </exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="offset" /> or <paramref name="numBytes" /> is negative. </exception>
    /// <exception cref="T:System.NotSupportedException">The stream does not support writing. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurred. </exception>
    /// <filterpriority>2</filterpriority>
    System.IAsyncResult BeginWrite(byte[] array, int offset, int numBytes, System.AsyncCallback userCallback, object stateObject);
    
    /// <summary>Waits for the pending asynchronous read operation to complete. (Consider using <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead; see the Remarks section.)</summary>
    /// <returns>The number of bytes read from the stream, between 0 and the number of bytes you requested. Streams only return 0 at the end of the stream, otherwise, they should block until at least 1 byte is available.</returns>
    /// <param name="asyncResult">The reference to the pending asynchronous request to wait for. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="asyncResult" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class. </exception>
    /// <exception cref="T:System.InvalidOperationException">
    ///  <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> is called multiple times. </exception>
    /// <exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
    /// <filterpriority>2</filterpriority>
    int EndRead(System.IAsyncResult asyncResult);
    
    /// <summary>Ends an asynchronous write operation and blocks until the I/O operation is complete. (Consider using <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> instead; see the Remarks section.)</summary>
    /// <param name="asyncResult">The pending asynchronous I/O request. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="asyncResult" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">This <see cref="T:System.IAsyncResult" /> object was not created by calling <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> on this class. </exception>
    /// <exception cref="T:System.InvalidOperationException">
    ///  <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> is called multiple times. </exception>
    /// <exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
    /// <filterpriority>2</filterpriority>
    void EndWrite(System.IAsyncResult asyncResult);
    
    /// <summary>Clears buffers for this stream and causes any buffered data to be written to the file.</summary>
    /// <exception cref="T:System.IO.IOException">An I/O error occurred. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <filterpriority>1</filterpriority>
    void Flush();
    
    /// <summary>Clears buffers for this stream and causes any buffered data to be written to the file, and also clears all intermediate file buffers.</summary>
    /// <param name="flushToDisk">true to flush all intermediate file buffers; otherwise, false. </param>
    void Flush(bool flushToDisk);
    
    /// <summary>Asynchronously clears all buffers for this stream, causes any buffered data to be written to the underlying device, and monitors cancellation requests. </summary>
    /// <returns>A task that represents the asynchronous flush operation. </returns>
    /// <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    /// <exception cref="T:System.ObjectDisposedException">The stream has been disposed.</exception>
    System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
    
    /// <summary>Gets a <see cref="T:System.Security.AccessControl.FileSecurity" /> object that encapsulates the access control list (ACL) entries for the file described by the current <see cref="T:System.IO.FileStream" /> object.</summary>
    /// <returns>An object that encapsulates the access control settings for the file described by the current <see cref="T:System.IO.FileStream" /> object.</returns>
    /// <exception cref="T:System.ObjectDisposedException">The file is closed.</exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurred while opening the file.</exception>
    /// <exception cref="T:System.SystemException">The file could not be found.</exception>
    /// <exception cref="T:System.UnauthorizedAccessException">This operation is not supported on the current platform.-or- The caller does not have the required permission.</exception>
    /// <filterpriority>1</filterpriority>
    System.Security.AccessControl.FileSecurity GetAccessControl();
    
    /// <summary>Prevents other processes from reading from or writing to the <see cref="T:System.IO.FileStream" />.</summary>
    /// <param name="position">The beginning of the range to lock. The value of this parameter must be equal to or greater than zero (0). </param>
    /// <param name="length">The range to be locked. </param>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="position" /> or <paramref name="length" /> is negative. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The file is closed. </exception>
    /// <exception cref="T:System.IO.IOException">The process cannot access the file because another process has locked a portion of the file.</exception>
    /// <filterpriority>2</filterpriority>
    void Lock(long position, long length);
    
    /// <summary>Reads a block of bytes from the stream and writes the data in a given buffer.</summary>
    /// <returns>The total number of bytes read into the buffer. This might be less than the number of bytes requested if that number of bytes are not currently available, or zero if the end of the stream is reached.</returns>
    /// <param name="array">When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1<paramref name=")" /> replaced by the bytes read from the current source. </param>
    /// <param name="offset">The byte offset in <paramref name="array" /> at which the read bytes will be placed. </param>
    /// <param name="count">The maximum number of bytes to read. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="array" /> is null. </exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="offset" /> or <paramref name="count" /> is negative. </exception>
    /// <exception cref="T:System.NotSupportedException">The stream does not support reading. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurred. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="offset" /> and <paramref name="count" /> describe an invalid range in <paramref name="array" />. </exception>
    /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
    /// <filterpriority>1</filterpriority>
    int Read(byte[] array, int offset, int count);
    
    /// <summary>Asynchronously reads a sequence of bytes from the current stream, advances the position within the stream by the number of bytes read, and monitors cancellation requests.</summary>
    /// <returns>A task that represents the asynchronous read operation. The value of the <paramref name="TResult" /> parameter contains the total number of bytes read into the buffer. The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached. </returns>
    /// <param name="buffer">The buffer to write the data into.</param>
    /// <param name="offset">The byte offset in <paramref name="buffer" /> at which to begin writing data from the stream.</param>
    /// <param name="count">The maximum number of bytes to read.</param>
    /// <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="buffer" /> is null.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="offset" /> or <paramref name="count" /> is negative.</exception>
    /// <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</exception>
    /// <exception cref="T:System.NotSupportedException">The stream does not support reading.</exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream has been disposed.</exception>
    /// <exception cref="T:System.InvalidOperationException">The stream is currently in use by a previous read operation. </exception>
    System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    
    /// <summary>Reads a byte from the file and advances the read position one byte.</summary>
    /// <returns>The byte, cast to an <see cref="T:System.Int32" />, or -1 if the end of the stream has been reached.</returns>
    /// <exception cref="T:System.NotSupportedException">The current stream does not support reading. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The current stream is closed. </exception>
    /// <filterpriority>1</filterpriority>
    int ReadByte();
    
    /// <summary>Sets the current position of this stream to the given value.</summary>
    /// <returns>The new position in the stream.</returns>
    /// <param name="offset">The point relative to <paramref name="origin" /> from which to begin seeking. </param>
    /// <param name="origin">Specifies the beginning, the end, or the current position as a reference point for <paramref name="offset" />, using a value of type <see cref="T:System.IO.SeekOrigin" />. </param>
    /// <exception cref="T:System.IO.IOException">An I/O error occurred. </exception>
    /// <exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the FileStream is constructed from a pipe or console output. </exception>
    /// <exception cref="T:System.ArgumentException">Seeking is attempted before the beginning of the stream. </exception>
    /// <exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception>
    /// <filterpriority>1</filterpriority>
    long Seek(long offset, System.IO.SeekOrigin origin);
    
    /// <summary>Applies access control list (ACL) entries described by a <see cref="T:System.Security.AccessControl.FileSecurity" /> object to the file described by the current <see cref="T:System.IO.FileStream" /> object.</summary>
    /// <param name="fileSecurity">An object that describes an ACL entry to apply to the current file.</param>
    /// <exception cref="T:System.ObjectDisposedException">The file is closed.</exception>
    /// <exception cref="T:System.ArgumentNullException">The <paramref name="fileSecurity" /> parameter is null.</exception>
    /// <exception cref="T:System.SystemException">The file could not be found or modified.</exception>
    /// <exception cref="T:System.UnauthorizedAccessException">The current process does not have access to open the file.</exception>
    /// <filterpriority>1</filterpriority>
    void SetAccessControl(System.Security.AccessControl.FileSecurity fileSecurity);
    
    /// <summary>Sets the length of this stream to the given value.</summary>
    /// <param name="value">The new length of the stream. </param>
    /// <exception cref="T:System.IO.IOException">An I/O error has occurred. </exception>
    /// <exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking. </exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">Attempted to set the <paramref name="value" /> parameter to less than 0. </exception>
    /// <filterpriority>2</filterpriority>
    void SetLength(long value);
    
    /// <summary>Allows access by other processes to all or part of a file that was previously locked.</summary>
    /// <param name="position">The beginning of the range to unlock. </param>
    /// <param name="length">The range to be unlocked. </param>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="position" /> or <paramref name="length" /> is negative. </exception>
    /// <filterpriority>2</filterpriority>
    void Unlock(long position, long length);
    
    /// <summary>Writes a block of bytes to the file stream.</summary>
    /// <param name="array">The buffer containing data to write to the stream.</param>
    /// <param name="offset">The zero-based byte offset in <paramref name="array" /> from which to begin copying bytes to the stream. </param>
    /// <param name="count">The maximum number of bytes to write. </param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="array" /> is null. </exception>
    /// <exception cref="T:System.ArgumentException">
    ///  <paramref name="offset" /> and <paramref name="count" /> describe an invalid range in <paramref name="array" />. </exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="offset" /> or <paramref name="count" /> is negative. </exception>
    /// <exception cref="T:System.IO.IOException">An I/O error occurred. - or -Another thread may have caused an unexpected change in the position of the operating system's file handle. </exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.NotSupportedException">The current stream instance does not support writing. </exception>
    /// <filterpriority>1</filterpriority>
    void Write(byte[] array, int offset, int count);
    
    /// <summary>Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests. </summary>
    /// <returns>A task that represents the asynchronous write operation.</returns>
    /// <param name="buffer">The buffer to write data from. </param>
    /// <param name="offset">The zero-based byte offset in <paramref name="buffer" /> from which to begin copying bytes to the stream.</param>
    /// <param name="count">The maximum number of bytes to write.</param>
    /// <param name="cancellationToken">The token to monitor for cancellation requests.</param>
    /// <exception cref="T:System.ArgumentNullException">
    ///  <paramref name="buffer" /> is null.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///  <paramref name="offset" /> or <paramref name="count" /> is negative.</exception>
    /// <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the buffer length.</exception>
    /// <exception cref="T:System.NotSupportedException">The stream does not support writing.</exception>
    /// <exception cref="T:System.ObjectDisposedException">The stream has been disposed.</exception>
    /// <exception cref="T:System.InvalidOperationException">The stream is currently in use by a previous write operation. </exception>
    System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
    
    /// <summary>Writes a byte to the current position in the file stream.</summary>
    /// <param name="value">A byte to write to the stream. </param>
    /// <exception cref="T:System.ObjectDisposedException">The stream is closed. </exception>
    /// <exception cref="T:System.NotSupportedException">The stream does not support writing. </exception>
    /// <filterpriority>1</filterpriority>
    void WriteByte(byte value);
  }
}
